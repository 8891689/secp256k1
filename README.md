# secp256k1 椭圆曲线密码学库 (C 实现)

## 简介

本项目使用 C 语言实现了 secp256k1 椭圆曲线密码学的核心算法。代码不依赖任何外部库，直接实现了所有必要的密码学原语。

## 实现细节

### 大整数运算

- 采用 `uint32_t` 数组 (长度为 8) 表示 256 位无符号整数 (`BigInt` 结构体)。
- 实现了大整数的加法、减法、乘法、比较和位操作（获取指定位）。
- 加法和减法直接模拟手工计算过程，处理进位和借位。
- 大整数乘法采用基础的逐字相乘算法，产生 512 位的结果。
- 比较操作从高位到低位逐字比较。
- 位操作通过移位和掩码实现。

### 模运算

- **模乘法 (`mul_mod`) 采用优化实现**:
    1.  首先计算两个 256 位大整数的乘积（512 位）。
    2.  将 512 位结果拆分为高 256 位 (H) 和低 256 位 (L)。
    3. 利用 secp256k1 曲线模数 `p` 的特殊形式 (p = 2^256 - 2^32 - 977) 进行快速约减：
        - 将 H 乘以 977, 结果记作 H977.
        - H 左移一个uint32_t字(32位), 结果记作Hshift.
        - 将 L, H977, Hshift 相加(9 个 `uint32_t` 字长), 结果记作 Rext.
        - 如果Rext有第九位(溢出位), 进行额外处理:
            - 将溢出位乘以977得到extra977, 左移得到extraShift.
            - Rext 加上 extra977 和 extraShift.
        - 将 Rext 转换为 `BigInt`.
    4.  如果结果仍然大于或等于 `p`，则最多进行两次减法。
- 模加法 (`add_mod`) 和模减法 (`sub_mod`) 在大整数加减法的基础上，进行一次或两次模 `p` 的减法。
- 模逆元 (`mod_inverse`) 使用费马小定理和模指数运算实现 (a<sup>p-2</sup> mod p)。
- 模指数运算 (`modexp`) 使用"从左到右"的平方-乘算法。
- 提供了优化的模约简函数(`efficient_mod`)，和通用模约简函数(`mod_generic`)，优化版本中比较结果大于等于p时,最多减两次p.

### 椭圆曲线点运算

- `ECPoint` 结构体表示椭圆曲线上的点，包含 x 坐标、y 坐标和一个表示是否为无穷远点的标志。
- 点加法 (`point_add`) 和倍点 (`double_point`) 运算根据标准公式实现，并处理无穷远点的情况。
- 标量乘法 (`scalar_multiply`) 使用经典的 "double-and-add" 算法：
    - 初始化结果点 R 为无穷远点。
    - 从标量的最高位到最低位遍历：
        - 将 R 加倍 (double_point)。
        - 如果当前位为 1，则将 R 与 P 相加 (point_add)。
    - 最终 R 即为结果。

### 辅助工具

- `print_bigint`: 将 `BigInt` 以十六进制格式打印。
- `hex_to_bigint`: 将十六进制字符串转换为 `BigInt`。
- `bigint_to_hex`: 将 `BigInt` 转换为十六进制字符串。

### 9字扩展运算

- 在模乘中对中间结果(512位), 用长度为9的 `uint32_t` 数组表示。
- 实现了大整数乘以常数、左移一个字（32位）、9 字长加法以及 9 字长数组到 `BigInt` 的转换。 这些函数用于模乘法的优化中。

## 编译

```bash
gcc -O3 -o test test.c secp256k1.c
```



